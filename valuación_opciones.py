# -*- coding: utf-8 -*-
"""Valuación_opciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s00MM5dHDObuhjAm3k-vpQrdRilJyNR6
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import scipy.stats as sc
import matplotlib as plt
import seaborn as sns
from google.colab import files
import pandas as pd
import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import statsmodels.api as sm
import subprocess

!pip install yfinance
import yfinance as yf

def peizer_pratt(z,n):
  h=.5+np.sign(z)*.5*np.sqrt(1-np.exp((-((z/(n+(1/3)+(.1/(n+1))))**2)*(n+(1/6)))))
  return(h)

def modelos_binomiales(precio_final,k,t,r,n,sigma,q=0,Call_Put=0,modelo='CRR'):
  t=t/365
  delta_t=t/n
  n_=n+1
  if modelo=='CRR':
    u=np.exp(sigma*np.sqrt(delta_t))
    d=1/u
    p=(np.exp((r-q)*delta_t)-d)/(u-d)
  if modelo=='JR':
    p=0.5
    u=np.exp((float(r)-float(q)-((float(sigma)**2)/2))*delta_t+float(sigma)*np.sqrt(delta_t))
    d=np.exp((float(r)-float(q)-((float(sigma)**2)/2))*delta_t-float(sigma)*np.sqrt(delta_t))
  if modelo=='LR':
    d1=(np.log(float(precio_final)/k)+t*(r-q+((sigma**2)/2)))/sigma*np.sqrt(t)
    d2=d1-volatilidad*np.sqrt(t)
    p=peizer_pratt(d2,n)
    p_prima=peizer_pratt(d1,n)
    u=np.exp((r-q)*delta_t)*(p_prima/p)
    d=np.exp((r-q)*delta_t)*((1-p_prima)/(1-p))
  n=n_

  precios=np.array(np.zeros(shape=(n,n)))
  precios[0][0]=precio_final
  for i in range(precios.shape[1]):
    for j in range(precios.shape[0]):
      if j==i:
        precios[j][j]=precios[0][0]*d**j
      if j>i:
        precios[i][j]=precios[i][j-1]*u
  precio_opciones=np.array(np.zeros(shape=(n,n)))

  if Call_Put==0:
    for i in range(precio_opciones.shape[0]):
      precio_opciones[i][n-1]=max(0,k-precios[i][n-1])
  else:
    for i in range(precio_opciones.shape[0]):
      precio_opciones[i][n-1]=max(0,precios[i][n-1]-k)

  k_=1
  for j in reversed(range(precio_opciones.shape[0]-1)):
    for i in range(precio_opciones.shape[0]-k_):
      precio_opciones[i][j]=(precio_opciones[i][j+1]*p+precio_opciones[i+1][j+1]*(1-p))*np.exp(-r*delta_t)
    k_+=1
  
  df_pre=pd.DataFrame(precios)
  df_opc=pd.DataFrame(precio_opciones)

  template = r'''
  \pdfminorversion=4
  \documentclass[preview]{{standalone}}
  \usepackage{{booktabs}}
  \begin{{document}}
  {}
  \end{{document}}
  '''

  with open('Precios.tex', 'w') as f:
      f.write(template.format(df_pre.to_latex()))
  with open('Opciones.tex', 'w') as f:
      f.write(template.format(df_opc.to_latex()))
  return precio_opciones

def vol_tasa(accion='MSFT',tasa_libre='^IRX'):
  accion = yf.Ticker(str(accion))
  hist = accion.history(period="365d")
  df_movimientos=hist['Close']
  df_movimientos=pd.DataFrame(df_movimientos)
  a=df_movimientos.diff()

  a=a.iloc[1:]
  ultimo_precio=df_movimientos.iloc[-1:]
  volatilidad=np.var(a)**(1/2)

  TBILL = yf.Ticker(str(tasa_libre))
  tasa_libre = TBILL.history(period="1d") 
  r=tasa_libre['Close']


  ultimo_precio=ultimo_precio.values
  volatilidad=volatilidad.values
  r=np.log(1+r.values)

  sns.set()
  hist['Close'].plot(figsize=(16, 9),label='Historia')
  plt.title(str(accion))
  plt.legend()
  return ultimo_precio[0][0],volatilidad[0],r[0]

vol_tasa(accion='MSFT',tasa_libre='^IRX')

def opciones_completas(k,t,n,accion='MSFT',tasa_libre='^IRX',q=0,Call_Put=0,modelo='CRR'):
  precio_final,sigma,r=vol_tasa(accion=str(accion),tasa_libre=str(tasa_libre))
  costo=modelos_binomiales(precio_final,k,t,r,n,sigma,q,Call_Put,modelo)
  return costo[0][0]

opciones_completas(k=215,t=21,n=15,accion='MSFT',tasa_libre='^IRX',q=0,Call_Put=0,modelo='JR')

def Bernoulli(tamaño,p,u=0):
  u = np.random.uniform(0,1,tamaño) if np.sum(u)==0  else np.array(u)
  v=np.where(u<=p,1,0)
  return np.array(v)

def Binomial(n,p,tamano,u=0):
  u = np.random.uniform(0,1,n*tamano) if np.sum(u)==0  else np.array(u)
  Bernoul = Bernoulli(n*tamano,p,u)
  print(range(len(Bernoul)//n))
  v = [np.sum(Bernoul[i*n:((1+i)*n)]) for i in range(len(Bernoul)//n)]
  return np.array(v)

"""# Nueva sección"""



from random import gauss
from math import exp, sqrt

def simular_comporta(Strike,sigma,r,t):
    return Strike * exp((r - 0.5 * sigma**2) * t + sigma * sqrt(t) * gauss(0,1.0))

def costo(strike_simulado,k,Call_Put=0):
  if Call_Put==0:
    return max(0,strike_simulado-k)
  else:
    return max(k-strike_simulado,0)

def montecarlo_opci(Strike,sigma,r,t,n=1,simula=1000):
  np.random.seed(10)
  simu=np.array([])
  t_=t
  t=(1/n)
  for j in range(int(simula)):
    strike=Strike
    traye=np.array([Strike])
    for i in range(t_):
      strike=simular_comporta(strike,sigma,r,t)
      traye=np.append(traye,strike)
    plt.plot(traye)
    simu=np.append(simu,strike)
  plt.title("Rendimientos")
  print(np.average(simu)*exp(-r*t_/n))
  return np.average(simu)*exp(-r*t_/n)

def precio_conmont(Strike,k,sigma,r,t,n,simu,Call_Put):
  np.random.seed(10)
  strike_simulado=montecarlo_opci(Strike,sigma,r,t,n,simu)
  costo_=costo(strike_simulado,k,Call_Put)
  return(costo_)

"""CALL=0 PUT=1"""

precio_conmont(Strike=213.25999450683594,k=220,sigma=4.030445706492088,r=0.06765864875234118,t=28,n=365,simu=100,Call_Put=0)

vol_tasa(accion='MSFT',tasa_libre='^IRX')

#def precio_montecarlo_opciones(t,n,k,simu=1000,Call_Put=0,accion='MSFT',tasa_libre='^IRX'):
 # Strike,sigma,r=vol_tasa(accion,tasa_libre)
  #a= precio_conmont(Strike=213.25999450683594,k=175,sigma=4.030445706492088,r=0.06765864875234118,t=180,n=365,simu=1000,Call_Put=0)
  #return a

Strike,sigma,r=vol_tasa('MSFT','^IRX')

"""##Pruebas fallidas"""



def binomial(dt,p,precio,u,d):
  ber = np.random.binomial(1,p,dt)
  r = np.zeros_like(ber)
  r = np.where(ber==0,d,u)
  r[0] *= precio
  for i in range(r.shape[0]-1):
    r[i+1] *= r[i]
  return np.insert(r,0,precio)
def simulacion_binomial_ameri(dt,p,precio,u,d,simu):
  res = np.array([])
  for i in range(simu):
    a = binomial(dt,p,precio,u,d)
    res = np.append(res,a[-1])
    plt.plot(a)
  return np.mean(res)

def opciones_amercianas_completas(k,t,n,accion='MSFT',tasa_libre='^IRX',q=0,Call_Put=0,modelo='CRR',simu=1000):
  t_=t
  t=t/365
  delta_t=t/n
  n_=n+1
  precio_final,sigma,r=vol_tasa(accion=str(accion),tasa_libre=str(tasa_libre))
  if modelo=='CRR':
    u=np.exp(sigma*np.sqrt(delta_t))
    d=1/u
    p=(np.exp((r-q)*delta_t)-d)/(u-d)
  if modelo=='JR':
    p=0.5
    u=np.exp((float(r)-float(q)-((float(sigma)**2)/2))*delta_t+float(sigma)*np.sqrt(delta_t))
    d=np.exp((float(r)-float(q)-((float(sigma)**2)/2))*delta_t-float(sigma)*np.sqrt(delta_t))
  if modelo=='LR':
    d1=(np.log(float(precio_final)/k)+t*(r-q+((sigma**2)/2)))/sigma*np.sqrt(t)
    d2=d1-volatilidad*np.sqrt(t)
    p=peizer_pratt(d2,n)
    p_prima=peizer_pratt(d1,n)
    u=np.exp((r-q)*delta_t)*(p_prima/p)
    d=np.exp((r-q)*delta_t)*((1-p_prima)/(1-p))
  n=n_
  precio_n=simulacion_binomial_ameri(delta_t*n,p,precio_final,u,d,simu)*np.exp(-t*r)
  if Call_Put==0:
    return max(0,precio_n*(p*u+p*d),-k)
  else:
    return max(k-precio_n*(p*u+p*d),0)

u



"""##SIMULACIÓN BINOMIAL"""

strike, sigma, r,q = 213.25999450683594, 4.030445706492088, 0.06765864875234118,0
delta_t = 28/365
p=0.5
u=np.exp((float(r)-float(0)-((float(sigma)**2)/2))*delta_t+float(sigma)*np.sqrt(delta_t))
d=np.exp((float(r)-float(0)-((float(sigma)**2)/2))*delta_t-float(sigma)*np.sqrt(delta_t))
res = np.array([])
for i in range(1000):
  a = binomial(28,.55,strike,1.1,.9)
  res = np.append(res,a[-1])
  plt.plot(a)
hola = (np.mean(res)*(.55*1.1+(1-.55)*.9))*np.exp(-delta_t*r)
hola-strike

def portafolio(acciones=['MSFT','AAPL'],posicion=[500,500],tasa_libre='^IRX',alpha=.05,modelo='historico',t=28,n=24,simu=100):
  df_precios=pd.DataFrame()
  TBILL = yf.Ticker(str(tasa_libre))
  tasa_libre = TBILL.history(period="2d") 
  r=tasa_libre['Close']
  r=np.log(1+r.values)
  for accion in acciones:
    hist = yf.Ticker(str(accion))
    hist = hist.history(period="365d")
    df_precios[str(accion)]=hist['Close']
  df_precios['portafolio']=np.sum(df_precios*posicion,axis=1)
  df_rendimientos=np.log(df_precios).diff()
  escenario= df_precios['portafolio'].iloc[-1]
  df_rendimientos=df_rendimientos.iloc[1:]
  if modelo=='historico':
    df_rendimientos['precio_proyectado']=(1+df_rendimientos['portafolio'])*escenario
    df_rendimientos['variaciones_simuladas']= np.log(df_rendimientos['precio_proyectado']/escenario)
    var=np.percentile(df_rendimientos['variaciones_simuladas'],1-alpha)*escenario
  if modelo=='historico_2':
    miu=np.average(df_rendimientos['portafolio'])
    sigma=np.var(df_rendimientos['portafolio'])**(1/2)   
    print(r)
    df_rendimientos['precio_proyectado']=escenario * np.exp((miu - 0.5 * sigma**2))*np.exp(sigma *np.random.standard_normal((364,1)))
    df_rendimientos['variaciones_simuladas']= np.log(df_rendimientos['precio_proyectado']/escenario)
    var=np.percentile(df_rendimientos['variaciones_simuladas'],1-alpha)*escenario
  if modelo=='Monte_Carlo':
    miu=np.average(df_rendimientos['portafolio'])
    sigma=(np.var(df_rendimientos['portafolio']))**(1/2)
    simulaciones=np.array([])
    for i in range(simu):
      portafolio_p=escenario
      traye=np.array([portafolio_p])
      for j in range(t*n):
        portafolio_p=portafolio_p * exp((miu - 0.5 * sigma**2) * (1/(t*n)))*np.exp(sigma * sqrt((1/(t*n)))*np.random.standard_normal(1)) 
        traye=np.append(traye,portafolio_p)
      
      simulaciones=np.append(simulaciones,portafolio_p)
      plt.plot(traye)
      plt.title('VaR Montecarlo')
    peor=np.percentile(simulaciones,1-alpha)
    var=(escenario-peor)*-1
  return var

portafolio(acciones=['MSFT','AAPL'],posicion=[500,500],tasa_libre='^IRX',alpha=.05,modelo='Monte_Carlo',t=28,n=24,simu=1000)

miu=0.46452521421161835
sigma=4.030445706492088
r= 0.06765864875234118
t=28
n=24
simu=1000
simulaciones=np.array([])
for i in range(simu):
  portafolio_p=213.25999450683594
  traye=np.array([portafolio_p])
  for j in range(t*n):
    portafolio_p=portafolio_p * exp((miu - 0.5 * sigma**2) * (1/(t*n)))*np.exp(sigma * sqrt((1/(t*n)))*np.random.standard_normal(1)) 
    traye=np.append(traye,portafolio_p)
      
  simulaciones=np.append(simulaciones,portafolio_p)
  plt.plot(traye)
plt.title('Opciones Montecarlo')
peor=np.average(simulaciones)*np.exp(-r*t)
213.25999450683594-peor

(213.25999450683594, 4.030445706492088, 0.06765864875234118)

for i in range(1000):
  a = binomial(40,.26,strike,1.1,.9)
  res = np.append(res,a[-1])
  plt.plot(a)

